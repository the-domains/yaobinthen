---
datePublished: '2016-11-25T05:29:12.314Z'
sourcePath: _posts/2016-11-13-replace-node_modulesbabel-preset-react-nativetransformstr.md
inFeed: true
isBasedOnUrl: 'https://gist.github.com/21be4baacbe56c1f25c423797cb6951c'
author:
  - name: alvinthen
    url: 'https://github.com/alvinthen'
    avatar:
      src: 'https://avatars.githubusercontent.com/u/771989?v=3'
via: {}
dateModified: '2016-11-25T05:29:11.172Z'
title: ''
publisher:
  url: 'http://github.com'
  name: GitHub
  domain: gist.github.com
description: ''
starred: false
_context: 'http://schema.org'
_type: Code

---
/**
     * Copyright 2004-present Facebook. All Rights Reserved.
     */
    
    /* eslint-disable */
    
    'use strict';
    
    /*eslint consistent-return: 0*/
    
    /**
     * Transforms function properties of the &grave;Symbol&grave; into
     * the presence check, and fallback string "@@<name>".
     *
     * Example:
     *
     *   Symbol.iterator;
     *
     * Transformed to:
     *
     *   typeof Symbol.iterator === 'function' ? Symbol.iterator : '@@iterator';
     */
    module.exports = function symbolMember(babel) {
      const t = babel.types;
    
      return {
        visitor: {
          MemberExpression(path) {
            if (!isAppropriateMember(path)) {
              return;
            }
    
            let node = path.node;
    
            path.replaceWith(
              t.conditionalExpression(
                t.binaryExpression(
                  '===',
                  t.unaryExpression(
                    'typeof',
                    t.identifier('Symbol'),
                    true
                  ),
                  t.stringLiteral('function')
                ),
                node,
                t.stringLiteral(&grave;@@${node.property.name}&grave;)
              )
            );
    
            // We should stop to avoid infinite recursion, since Babel
            // traverses replaced path, and again would hit our transform.
            path.stop();
          },
        },
      };
    };
    
    function isAppropriateMember(path) {
      let node = path.node;
    
      return path.parentPath.type !== 'AssignmentExpression' &&
        node.object.type === 'Identifier' &&
        node.object.name === 'Symbol' &&
        node.property.type === 'Identifier';
    }